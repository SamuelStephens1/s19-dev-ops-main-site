// scripts/gen-env-types.mjs
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { dirname, resolve } from "node:path";
import toml from "toml";

const ROOT = process.cwd();
const WRANGLER = resolve(ROOT, "wrangler.toml");
const OUT = resolve(ROOT, "src/env.d.ts");

// Helpers
const banner =
  `// ⚠️ AUTO-GENERATED by scripts/gen-env-types.mjs — do not edit by hand.
// Run: npm run gen:envtypes
// This file is generated from your wrangler.toml bindings.\n\n`;

if (!existsSync(WRANGLER)) {
  console.error("wrangler.toml not found at project root.");
  process.exit(1);
}

const raw = readFileSync(WRANGLER, "utf8");
const cfg = toml.parse(raw);

// Support top-level and [env.production]/[env.<name>] fallbacks
const cf = cfg; // users typically bind at top-level; extend if you need per-env sections

// Collect bindings
const kv = (cf.kv_namespaces || []).map(b => b.binding);
const r2 = (cf.r2_buckets || []).map(b => b.binding);
const d1 = (cf.d1_databases || []).map(b => b.binding);
const queues = (cf.queues && cf.queues.producers ? cf.queues.producers.map(b => b.binding) : []);
const services = (cf.services || []).map(b => b.binding);
const durable = (cf.durable_objects && cf.durable_objects.bindings ? cf.durable_objects.bindings.map(b => b.name || b.class_name || b.binding) : []); // name is binding in old formats
const vars = cf.vars || {}; // plain env vars/secrets (strings)
const ai = cf.ai ? ["AI"] : []; // { ai = { binding = "AI" } } newer format
const vectorize = (cf.vectorize || []).map(b => b.binding);
const hyperdrive = (cf.hyperdrive || []).map(b => b.binding);

// Build interface fields
const lines = [];

kv.forEach(name => lines.push(`  ${name}: KVNamespace;`));
r2.forEach(name => lines.push(`  ${name}: R2Bucket;`));
d1.forEach(name => lines.push(`  ${name}: D1Database;`));
queues.forEach(name => lines.push(`  ${name}: Queue;`));
services.forEach(name => lines.push(`  ${name}: Service;`));
durable.forEach(name => lines.push(`  ${name}: DurableObjectNamespace;`));
vectorize.forEach(name => lines.push(`  ${name}: VectorizeIndex;`));
hyperdrive.forEach(name => lines.push(`  ${name}: Hyperdrive;`));
ai.forEach(name => lines.push(`  ${name}: Ai;`));

// Vars/secrets → string
Object.keys(vars).forEach(k => lines.push(`  ${k}: string;`));

// Ensure src/ exists
const outDir = dirname(OUT);
if (!existsSync(outDir)) mkdirSync(outDir, { recursive: true });

// Emit d.ts
const content = `${banner}/// <reference types="@cloudflare/workers-types" />

// Extra CF types (Vectorize/Hyperdrive/Ai) may not exist in older workers-types versions.
// Fallback shims so TS doesn't error if your package doesn't include them.
type VectorizeIndex = any;
type Hyperdrive = any;
type Ai = any;

type Runtime = import("@astrojs/cloudflare").Runtime<Env>;

// Generated from wrangler.toml
interface Env {
${lines.length ? lines.join("\n") : "  // (no bindings declared in wrangler.toml)\n"}
}

declare namespace App {
  interface Locals extends Runtime {}
}
`;

writeFileSync(OUT, content);
console.log(`Generated ${OUT} from wrangler.toml`);
